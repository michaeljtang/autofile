use super::Preprocessor;
use anyhow::{Context, Result};
use std::path::{Path, PathBuf};

/// Preprocessor that renames images using AI-generated descriptions
///
/// This preprocessor uses a vision model (via candle-rs) to:
/// 1. Analyze the image content
/// 2. Generate a descriptive caption
/// 3. Rename the file based on the caption
///
/// Example: IMG_1234.jpg -> sunset_over_mountains_2024.jpg
///
/// NOTE: Vision model implementation is currently disabled by default.
/// The infrastructure is in place - you need to:
/// 1. Choose a vision model (BLIP-2, LLaVA, or custom)
/// 2. Implement the model loading and inference
/// 3. Enable in config.toml
pub struct ImageRenamer {
    enabled: bool,
}

impl ImageRenamer {
    pub fn new() -> Self {
        // Disabled by default - requires vision model implementation
        log::info!("Image renamer initialized (disabled - vision model not implemented)");
        Self { enabled: false }
    }

    /// Check if the file is an image that should be renamed
    fn is_renameable_image(&self, path: &Path) -> bool {
        if let Some(ext) = path.extension() {
            let ext_str = ext.to_str().unwrap_or("").to_lowercase();
            matches!(
                ext_str.as_str(),
                "jpg" | "jpeg" | "png" | "webp" | "bmp" | "gif"
            )
        } else {
            false
        }
    }

    /// Check if the filename looks like it was auto-generated by a camera
    /// Examples: IMG_1234.jpg, DSC_5678.png, 20231215_143022.jpg
    fn has_generic_name(&self, path: &Path) -> bool {
        if let Some(stem) = path.file_stem() {
            let stem_str = stem.to_str().unwrap_or("");

            // Common camera filename patterns
            let patterns = [
                stem_str.starts_with("IMG_"),
                stem_str.starts_with("DSC_"),
                stem_str.starts_with("DCIM_"),
                stem_str.starts_with("PXL_"),
                stem_str.chars().all(|c| c.is_ascii_digit() || c == '_'),
            ];

            patterns.iter().any(|&p| p)
        } else {
            false
        }
    }

    /// Generate a descriptive filename from image content
    /// TODO: Implement with vision model of your choice
    fn generate_descriptive_name(&self, _image_path: &Path) -> Result<String> {
        // Vision model not yet implemented
        // See VISION_MODEL_GUIDE.md for implementation instructions
        Err(anyhow::anyhow!("Vision model not implemented"))
    }

    /// Sanitize a caption to make it a valid filename
    fn sanitize_filename(&self, caption: &str) -> String {
        caption
            .to_lowercase()
            .chars()
            .map(|c| match c {
                'a'..='z' | '0'..='9' => c,
                ' ' | '-' | '_' => '_',
                _ => '_',
            })
            .collect::<String>()
            .split('_')
            .filter(|s| !s.is_empty())
            .collect::<Vec<_>>()
            .join("_")
            .chars()
            .take(50) // Limit filename length
            .collect()
    }

    /// Rename the image file with a descriptive name
    fn rename_image(&self, path: &Path) -> Result<PathBuf> {
        // Generate descriptive name from image content
        let description = self.generate_descriptive_name(path)?;
        let sanitized = self.sanitize_filename(&description);

        // Add timestamp to avoid conflicts
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();

        // Construct new filename
        let extension = path.extension().and_then(|e| e.to_str()).unwrap_or("jpg");
        let new_filename = format!("{}_{}.{}", sanitized, timestamp, extension);

        // Build new path in the same directory
        let new_path = path.parent()
            .ok_or_else(|| anyhow::anyhow!("Could not get parent directory"))?
            .join(new_filename);

        // Rename the file
        std::fs::rename(path, &new_path)
            .context("Failed to rename image file")?;

        log::info!("Renamed image: {:?} -> {:?}", path, new_path);

        Ok(new_path)
    }
}

impl Preprocessor for ImageRenamer {
    fn name(&self) -> &str {
        "AI Image Renamer"
    }

    fn should_process(&self, path: &Path) -> bool {
        self.enabled
            && self.is_renameable_image(path)
            && self.has_generic_name(path)
    }

    fn process(&self, path: &Path) -> Result<PathBuf> {
        // If renaming is disabled or fails, just return original path
        match self.rename_image(path) {
            Ok(new_path) => Ok(new_path),
            Err(e) => {
                log::debug!("Image renaming failed (expected if not implemented yet): {}", e);
                Ok(path.to_path_buf())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generic_name_detection() {
        let renamer = ImageRenamer::new();

        assert!(renamer.has_generic_name(Path::new("IMG_1234.jpg")));
        assert!(renamer.has_generic_name(Path::new("DSC_5678.png")));
        assert!(renamer.has_generic_name(Path::new("20231215_143022.jpg")));

        assert!(!renamer.has_generic_name(Path::new("my_vacation_photo.jpg")));
        assert!(!renamer.has_generic_name(Path::new("sunset.png")));
    }

    #[test]
    fn test_filename_sanitization() {
        let renamer = ImageRenamer::new();

        assert_eq!(
            renamer.sanitize_filename("A beautiful sunset over the ocean"),
            "a_beautiful_sunset_over_the_ocean"
        );

        assert_eq!(
            renamer.sanitize_filename("Cat!!! @#$ playing with yarn???"),
            "cat_playing_with_yarn"
        );
    }
}
