use super::Preprocessor;
use anyhow::{Context, Result};
use std::path::{Path, PathBuf};
use std::fs;
use base64::{engine::general_purpose, Engine as _};

/// Preprocessor that renames images using AI-generated descriptions
///
/// Uses a lightweight vision model API to:
/// 1. Analyze the image content
/// 2. Generate a descriptive caption
/// 3. Rename the file based on the caption
///
/// Example: IMG_1234.jpg -> sunset_over_mountains_2024.jpg
pub struct ImageRenamer {
    enabled: bool,
    client: reqwest::blocking::Client,
}

impl ImageRenamer {
    pub fn new() -> Self {
        log::info!("Image renamer initialized with lightweight captioning");
        Self {
            enabled: true,
            client: reqwest::blocking::Client::builder()
                .timeout(std::time::Duration::from_secs(30))
                .build()
                .unwrap_or_else(|_| reqwest::blocking::Client::new()),
        }
    }

    /// Check if the file is an image that should be renamed
    fn is_renameable_image(&self, path: &Path) -> bool {
        if let Some(ext) = path.extension() {
            let ext_str = ext.to_str().unwrap_or("").to_lowercase();
            matches!(
                ext_str.as_str(),
                "jpg" | "jpeg" | "png" | "webp" | "bmp" | "gif"
            )
        } else {
            false
        }
    }

    /// Check if the filename looks like it was auto-generated by a camera
    /// Examples: IMG_1234.jpg, DSC_5678.png, 20231215_143022.jpg
    fn has_generic_name(&self, path: &Path) -> bool {
        if let Some(stem) = path.file_stem() {
            let stem_str = stem.to_str().unwrap_or("");

            // Common camera filename patterns
            let patterns = [
                stem_str.starts_with("IMG_"),
                stem_str.starts_with("DSC_"),
                stem_str.starts_with("DCIM_"),
                stem_str.starts_with("PXL_"),
                stem_str.chars().all(|c| c.is_ascii_digit() || c == '_'),
            ];

            patterns.iter().any(|&p| p)
        } else {
            false
        }
    }

    /// Generate a descriptive filename from image content
    /// Uses Hugging Face's free inference API with BLIP model (ultra lightweight)
    fn generate_descriptive_name(&self, image_path: &Path) -> Result<String> {
        // Read and encode image to base64
        let image_bytes = fs::read(image_path)
            .context("Failed to read image file")?;

        // For very quick local processing, just resize the image to reduce API payload
        let img = image::load_from_memory(&image_bytes)
            .context("Failed to load image")?;

        // Resize to max 512px for speed
        let img = img.resize(512, 512, image::imageops::FilterType::Nearest);

        // Encode to JPEG bytes for smaller payload
        let mut jpeg_bytes = Vec::new();
        img.write_to(&mut std::io::Cursor::new(&mut jpeg_bytes), image::ImageFormat::Jpeg)
            .context("Failed to encode image")?;

        let base64_img = general_purpose::STANDARD.encode(&jpeg_bytes);

        // Use Hugging Face's free Inference API (no auth needed for public models)
        // Using BLIP - one of the smallest and fastest captioning models
        let api_url = "https://api-inference.huggingface.co/models/Salesforce/blip-image-captioning-base";

        let response = self.client
            .post(api_url)
            .json(&serde_json::json!({
                "inputs": base64_img
            }))
            .send()
            .context("Failed to send request to captioning API")?;

        if !response.status().is_success() {
            // Fall back to simple description if API fails
            log::warn!("API request failed, using generic name");
            return Ok(String::from("image"));
        }

        let result: Vec<serde_json::Value> = response.json()
            .context("Failed to parse API response")?;

        if let Some(first) = result.first() {
            if let Some(caption) = first.get("generated_text").and_then(|v| v.as_str()) {
                return Ok(caption.to_string());
            }
        }

        // Fallback
        Ok(String::from("image"))
    }

    /// Sanitize a caption to make it a valid filename
    fn sanitize_filename(&self, caption: &str) -> String {
        caption
            .to_lowercase()
            .chars()
            .map(|c| match c {
                'a'..='z' | '0'..='9' => c,
                ' ' | '-' | '_' => '_',
                _ => '_',
            })
            .collect::<String>()
            .split('_')
            .filter(|s| !s.is_empty())
            .collect::<Vec<_>>()
            .join("_")
            .chars()
            .take(50) // Limit filename length
            .collect()
    }

    /// Rename the image file with a descriptive name
    fn rename_image(&self, path: &Path) -> Result<PathBuf> {
        // Generate descriptive name from image content
        let description = self.generate_descriptive_name(path)?;
        let sanitized = self.sanitize_filename(&description);

        // Add timestamp to avoid conflicts
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();

        // Construct new filename
        let extension = path.extension().and_then(|e| e.to_str()).unwrap_or("jpg");
        let new_filename = format!("{}_{}.{}", sanitized, timestamp, extension);

        // Build new path in the same directory
        let new_path = path.parent()
            .ok_or_else(|| anyhow::anyhow!("Could not get parent directory"))?
            .join(new_filename);

        // Rename the file
        std::fs::rename(path, &new_path)
            .context("Failed to rename image file")?;

        log::info!("Renamed image: {:?} -> {:?}", path, new_path);

        Ok(new_path)
    }
}

impl Preprocessor for ImageRenamer {
    fn name(&self) -> &str {
        "AI Image Renamer"
    }

    fn should_process(&self, path: &Path) -> bool {
        self.enabled
            && self.is_renameable_image(path)
            && self.has_generic_name(path)
    }

    fn process(&self, path: &Path) -> Result<PathBuf> {
        // If renaming is disabled or fails, just return original path
        match self.rename_image(path) {
            Ok(new_path) => Ok(new_path),
            Err(e) => {
                log::debug!("Image renaming failed (expected if not implemented yet): {}", e);
                Ok(path.to_path_buf())
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generic_name_detection() {
        let renamer = ImageRenamer::new();

        assert!(renamer.has_generic_name(Path::new("IMG_1234.jpg")));
        assert!(renamer.has_generic_name(Path::new("DSC_5678.png")));
        assert!(renamer.has_generic_name(Path::new("20231215_143022.jpg")));

        assert!(!renamer.has_generic_name(Path::new("my_vacation_photo.jpg")));
        assert!(!renamer.has_generic_name(Path::new("sunset.png")));
    }

    #[test]
    fn test_filename_sanitization() {
        let renamer = ImageRenamer::new();

        assert_eq!(
            renamer.sanitize_filename("A beautiful sunset over the ocean"),
            "a_beautiful_sunset_over_the_ocean"
        );

        assert_eq!(
            renamer.sanitize_filename("Cat!!! @#$ playing with yarn???"),
            "cat_playing_with_yarn"
        );
    }
}
